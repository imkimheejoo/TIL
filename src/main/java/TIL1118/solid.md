## SOLID

### 단일 책임 원칙

- **클래스는 단 한 개의 책임을 가져야 한다.**
- 클래스가 한 개의 이유로만 변경되려면 클래스는 한 개의 책임만을 가져야 함
- 하지만 한 가지 책임에 대한 정의가 명확하지 않고, 책임을 도출하기 위해서는 다양한 경험이 필요함
- 책임의 개수가 많아질수록 한 책임의 기능 변화가 다른 책임에 주는 영향은 비례해서 증가하게 됨 → ex) 파일 읽어서 보여주기
- 책임을 구분하는 기준
    - C클래스에는 add,sub메서드가존재할때
    - A클래스는 add메서드 B클래스는 sub메서드를 사용한다면 다른 책임으로 봄

### 개방 폐쇄 원칙

- 확장에는 열려있고 변경에는 닫혀있어야 함 = **기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.**
- 개방 폐쇄 원칙이 깨질 때의 주요 증상
    - 다운캐스팅을 함 (instanceof)
    - 비슷한 if-else 블록이 존재
    - 개방 폐쇄 원칙은 **변화가 예상되는 것을 추상화**해서 변경의 유연함을 얻도록 해준다

### 리스코프 치환 원칙

- **상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상으로 동작해야한다.**
    - 다형성에 관한 원칙을 제공
    - ex) 어떤 메서드에 하위 타입의 객체를 전달해도 메서드가 정상적으로 동작해야 함 → 직사각형, 정사각형
    - ex) 상위 타입에서 지정한 리턴 값의 범위에 해당 되지 않는 값을 리턴
    - 리스코프 치환 원칙이 제대로 지켜지지 않으면 다형성에 기반한 개방 폐쇄 원칙 역시 지켜지지 X
    - 상위 타입에서 지정한 리턴 값의 범위에 해당되지 않는 값을 리턴
    - 리스코프 치환 원칙은 계약과 확장에 대한 것
        - 기능 실행의 계약과 관련해서 흔히 발생하는 위반사례
        - 1. 명시된 명세에서 벗어난 값을 리턴 → 리턴값은 0이나 또는 그 이상을 리턴하라고 정의 But 하위 타입에서 음수를 리턴
        - 2. 명시된 명세에서 벗어난 익셉션 발생 → IOException 발생된다고 했는데 하위 타입에서 IllegalException 던짐
        - 3. 명시된 명세에서 벗어난 기능을 수행
    - **하위 타입은 상위 타입에서 정의한 명세를 벗어나지 않는 범위에서 구현해야 함**
    - 리스코프 치환원칙은 **확장**에 관한 것
        - **타입을 확인하는 기능(instanceof)을 사용한다는 것은 상위 타입 만을 사용해서 프로그래밍을 할 수 없다는 것을 의미**
        - 이는 하위타입이 상위 타입을 대체할 수 없다는 것을 의미
        - **이는 SpecialItem과 같은 새로운 종류의 하위 타입이 생길 때 마다 상위 타입을 사용하는 코드를 수정해줘야 할 가능성을 높이게 됨**
        - Item을 확장하는 SpecialItem을 추가하는 과정에서 Coupon의 수정은 닫혀있어야 하는 데, Item을 확장하면서 Coupon을 수정 → **확장할 때 더 많은 코드를 수정할 가능성이 높아짐**
        - 문제 원인 : Item에 대한 추상화가 덜 되었음
            - 가격할인 여부는 Item 및 그 하위 타입에서 변화 되는 부분

        ### 인터페이스 분리 원칙

        - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야함
        - 자신과 관련없는 메서드들은 구현하지 말아야 한다
        - **클라이언트가 사용하지 않는 메서드에 의존하지 않아야 한다고 한다.**
        - [http://wonwoo.ml/index.php/post/1675](http://wonwoo.ml/index.php/post/1675)

        ### 의존 역전 원칙

        [http://wonwoo.ml/index.php/post/1717](http://wonwoo.ml/index.php/post/1717)

        - **고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.**
            - 고수준 : 어떤 의미있는 단일 기능을 제공하는 모듈
            - 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현
        - 고수준 모듈이 저수준 모듈에 의존 할 때의 문제점
            - ex) 가격계산 → 쿠폰 (의존)
                - 쿠폰이 변경될 때 마다 가격계산로직이 변경
        - 의존 역전 원칙을 통한 변경의 유연함 확보
            - 저수준 모듈이 고수준 모듈을 의존하게 만들어서 해결한다. → **추상화**
            FileDataReader,FlowController 모두 추상타입에 의존하게 변경

            - 의존역전원칙은 리스코프 치환 원칙과 함꼐 개방 폐쇄 원칙을 따르는 설계를 만들어 주는 기반
        - 소스 코드 의존과 런타임 의존
            - 의존 역전 원칙은 소스 코드에서의 의존을 역전 시키는 원칙

        ## SOLID 정리

        ### SRP ,ISP : 객체가 커지지 않도록 막아줌

        - 객체가 많은 기능을 가지게 되면, **객체가 가진 기능의 변경여파가 그 객체의 다른 기능에까지 번지게 되고** 이는 다시 다른 기능을 사용하는 클라이언트에게까지 영향을 준다.
        - 객체가 단일 책임을 갖게 히고 클라이언트마다 다른 인터페이스를 사용하게 함으로써 한 기능의 변경이 다른 곳에서까지 미치는 영향을 최소화 할 수 있음

        ### LSP, DIP : 개방폐쇄 원칙을 지원

        - 개방 폐쇄 원칙은 **변화 되는 부분을 추상화 하고 다형성을 이용함**으로써 기능 확장을 하면서도 기존코드를 수정하지 않도록 만들어줌
        - 여기서 변화되는 부분을 추상화 할 수 있도록 도와주는 원칙이 DIP이고 다형성을 도와주는 원칙이 리스코프 치환 원칙